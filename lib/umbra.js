"use strict";function t(t){return t&&t.__esModule&&Object.prototype.hasOwnProperty.call(t,"default")?t.default:t}function e(t,e){return t(e={exports:{}},e.exports),e.exports}Object.defineProperty(exports,"__esModule",{value:!0});class n{exec(t){if(1===t.length)return new Promise((e,n)=>{t(t=>{t instanceof Error?n(t):e(t)})});try{return Promise.resolve(t())}catch(t){return Promise.reject(t)}}}class s extends Error{constructor(t,e,n){super(t),this.timeoutMs=n}}class r{wrap(t,e){if(e<=0)return t;const n=Date.now();let r=null;const i=new Promise((t,i)=>{r=setTimeout(()=>{const t=Date.now()-n;i(new s(`Async task timeout exceeded! Elapsed: ${t}, timeout: ${e}ms.`,t,e))},e)});return t.catch(()=>{clearTimeout(r)}),Promise.race([t,i]).then(t=>(clearTimeout(r),t))}}const i={timeoutMs:100,stopOnFirstFail:!1};function o(t,e){if(!t)return e||[];if(!e)return t;for(const n of e)-1===t.indexOf(n)&&t.push(n);return t}function c(t,e){if(!t)return[];const n=t.indexOf(e);return-1!==n&&t.splice(n,1),t}class a{constructor(){this.onListeners={},this.onceListeners={}}on(t,e){this.onListeners[t]=o(this.onListeners[t],[e])}once(t,e){this.onceListeners[t]=o(this.onceListeners[t],[e])}off(t,e){this.onListeners[t]=c(this.onListeners[t],e),this.onceListeners[t]=c(this.onceListeners[t],e)}emit(t,...e){if(this.onListeners[t])for(const n of this.onListeners[t])n.call(null,...e);if(this.onceListeners[t]&&this.onceListeners[t].length>0){for(const n of this.onceListeners[t])n.call(null,...e);this.onceListeners[t]=[]}}emitAndWaitForCompletion(t,...e){const n=[];if(this.onListeners[t])for(const s of this.onListeners[t])try{n.push(Promise.resolve(s.call(null,...e)))}catch(t){n.push(Promise.reject(t))}if(this.onceListeners[t]&&this.onceListeners[t].length>0){for(const s of this.onceListeners[t])try{n.push(Promise.resolve(s.call(null,...e)))}catch(t){n.push(Promise.reject(t))}this.onceListeners[t]=[]}return Promise.all(n).then(t=>{})}}const u=["before","beforeEach","after","afterEach"];var l=Object.freeze({__proto__:null,TestRunner:class{constructor(t,e=new a){this.asyncPromisifier=new n,this.timeoutPromisifier=new r,this.testQueueStack=[],this.queueStacks={before:[[]],beforeEach:[[]],after:[[]],afterEach:[[]]},this.hasAnOnlyDescribe=!1,this.hasAnOnlyIt=!1,this.currentTest=null,this.testRunCancelled=!1,this.describe=(t,e)=>{this.throwIfTestInProgress("describe"),this.pushToCurrentTestQueue("describe",t,e)},this.describeOnly=(t,e)=>{this.throwIfTestInProgress("describe.only"),this.hasAnOnlyDescribe=!0,this.pushToCurrentTestQueue("describe",t,e,!0)},this.it=(t,e,n)=>{this.throwIfTestInProgress("it"),this.pushToCurrentTestQueue("it",t,e,!1,n?n.timeoutMs:void 0)},this.itOnly=(t,e,n)=>{this.throwIfTestInProgress("it.only"),this.hasAnOnlyIt=!0,this.pushToCurrentTestQueue("it",t,e,!0,n?n.timeoutMs:void 0)},this.runNextTestQueue=()=>{if(0===this.testQueueStack.length)return Promise.resolve();const t=this.testQueueStack.shift();let e=!1,n=Promise.resolve();for(let s=0;s<t.tests.length;s++){const r=t.tests[s];r.absoluteFilePath!==this.currentlyExecutingFilePath&&(this.currentlyExecutingFilePath=r.absoluteFilePath,this.eventEmitter.emit("activeFileChanged",this.currentlyExecutingFilePath)),n=n.then(()=>{if(!this.testRunCancelled)return"describe"===r.type?this.evaluateDescribe(t,r):this.evaluateTest(t,r).then(t=>{e=t})})}return n.then(()=>{if(e)return this.evaluateQueueWithTimeout("after")})},this.throwIfTestInProgress=t=>{if(this.currentTest)throw new Error(`Cannot add an ${t} block while executing a test!`)},this.resetRunResults=()=>{this.runResults={elapsedTimeMs:0,totalTests:0,totalSuccesses:0,totalFailures:0,totalTimeouts:0,failureInfo:[],timeoutInfo:[]}},this.config=function(t,e){if(!e||"object"!=typeof e)return t;if("object"==typeof t.timeoutMs&&"object"==typeof e.timeoutMs)for(const n of["it","before","beforeEach","after","afterEach"])"number"==typeof e.timeoutMs[n]&&(t.timeoutMs[n]=e.timeoutMs[n]);else void 0!==e.timeoutMs&&(t.timeoutMs=e.timeoutMs);return t.stopOnFirstFail!==e.stopOnFirstFail&&(t.stopOnFirstFail=e.stopOnFirstFail),t}(i,t),this.eventEmitter=e,this.it.only=this.itOnly,this.describe.only=this.describeOnly,this.resetRunResults()}setCurrentFile(t){this.lastFilePathSet=t}on(t,e){this.eventEmitter.on(t,e)}once(t,e){this.eventEmitter.once(t,e)}off(t,e){this.eventEmitter.off(t,e)}before(t){this.throwIfTestInProgress("before"),this.queueStacks.before[0].push(t)}beforeEach(t){this.throwIfTestInProgress("beforeEach"),this.queueStacks.beforeEach[0].push(t)}after(t){this.throwIfTestInProgress("after"),this.queueStacks.after[0].push(t)}afterEach(t){this.throwIfTestInProgress("afterEach"),this.queueStacks.afterEach[0].push(t)}run(){if(this.currentRun)throw new Error("Can't start a test run if one is already in progress!");return this.currentRun=this.runNextTestQueue().then(()=>{const t=this.runResults;return this.resetRunResults(),t}).finally(()=>{this.currentRun=null}),this.currentRun}getCurrentTestInfo(){if(!this.currentTest)throw new Error("Can't obtain TestInfo if not actively in a test!");return this.currentTest}reset(){if(this.currentRun)throw new Error("Can't reset if a test run is already in progress!");this.resetRunResults(),this.testRunCancelled=!1,this.hasAnOnlyIt=!1,this.hasAnOnlyDescribe=!1,this.testQueueStack=[];for(const t of u)this.queueStacks[t]=[[]]}cancel(){if(this.currentRun)return this.testRunCancelled=!0,this.currentRun.then(t=>(this.reset(),t))}pushToCurrentTestQueue(t,e,n,s,r){if(0===this.testQueueStack.length){const t={titleChain:[],tests:[],evaluatedBefores:!1};this.testQueueStack.push(t)}const i=this.testQueueStack[this.testQueueStack.length-1],o={title:e,type:t,callback:n,absoluteFilePath:this.lastFilePathSet};s&&(o.only=s),r>0&&(o.timeoutMs=r),i.tests.push(o)}evaluateDescribe(t,e){if(this.hasAnOnlyDescribe&&!e.only)return Promise.resolve();this.testQueueStack.push({titleChain:[].concat(t.titleChain,e.title),tests:[],evaluatedBefores:!1});for(const t of u)this.queueStacks[t].push([]);this.eventEmitter.emit("beforeDescribe",e.title);const n=Date.now();return this.asyncPromisifier.exec(e.callback).then(this.runNextTestQueue).then(()=>{for(const t of u)this.queueStacks[t].shift();const t=Date.now()-n;this.eventEmitter.emit("afterDescribe",e.title,t)})}evaluateTest(t,e){if(this.hasAnOnlyIt&&!e.only)return Promise.resolve(!1);let n=Promise.resolve();return t.evaluatedBefores||(t.evaluatedBefores=!0,n=n.then(()=>this.evaluateQueueWithTimeout("before"))),n.then(()=>this.evaluateQueueWithTimeout("beforeEach").then(()=>{this.eventEmitter.emit("beforeTest",e.title);const n=Date.now();this.currentTest=e;const r=e.timeoutMs>=0?e.timeoutMs:this.getTimeoutValue("it");return this.timeoutPromisifier.wrap(this.asyncPromisifier.exec(e.callback),r).then(()=>this.eventEmitter.emitAndWaitForCompletion("beforeTestSuccess",e.title)).then(()=>{this.runResults.totalSuccesses++;const t=Date.now()-n;this.eventEmitter.emit("testSuccess",e.title,t)}).catch(r=>{r instanceof s?(this.runResults.totalTimeouts++,this.runResults.timeoutInfo.push({describeChain:t.titleChain,title:e.title,elapsedMs:r.elapsedMs,timeoutMs:r.timeoutMs}),this.eventEmitter.emit("testTimeout",e.title,r.elapsedMs,r.timeoutMs)):(this.runResults.totalFailures++,this.runResults.failureInfo.push({describeChain:t.titleChain,title:e.title,error:r}),this.eventEmitter.emit("testFail",e.title,r,Date.now()-n)),this.config.stopOnFirstFail&&(this.testRunCancelled=!0)}).then(()=>this.evaluateQueueWithTimeout("afterEach")).finally(()=>{this.runResults.totalTests++,this.currentTest=null})})).then(()=>!0)}evaluateQueueWithTimeout(t){return this.timeoutPromisifier.wrap(this.evaluateQueue(t),this.getTimeoutValue(t))}evaluateQueue(t){const e=this.queueStacks[t];let n=Promise.resolve();if("before"===t||"beforeEach"===t)for(let t=0;t<e.length;t++){const s=e[t];for(let t=0;t<s.length;t++)n=n.then(()=>this.asyncPromisifier.exec(s[t]))}else for(let t=e.length-1;t>=0;t--){const s=e[t];for(let t=s.length-1;t>=0;t--)n=n.then(()=>this.asyncPromisifier.exec(s[t]))}return n}getTimeoutValue(t){return"number"==typeof this.config.timeoutMs?this.config.timeoutMs:this.config.timeoutMs[t]}}}),h=e((function(t,e){function n(t,e){return t===e||(t instanceof Date&&e instanceof Date?t.getTime()===e.getTime():!s(t)||!s(e)||"object"!=typeof t&&"object"!=typeof e?t===e:function(t,e){let r,i,o,c;if(!s(t)||!s(e))return!1;if(t.prototype!==e.prototype)return!1;try{o=Object.keys(t),c=Object.keys(e)}catch(t){return!1}if(o.length!==c.length)return!1;for(o.sort(),c.sort(),r=o.length-1;r>=0;r--)if(o[r]!==c[r])return!1;for(r=o.length-1;r>=0;r--)if(i=o[r],!n(t[i],e[i]))return!1;return typeof t==typeof e}(t,e))}function s(t){return null!=t}Object.defineProperty(e,"__esModule",{value:!0}),e.deepEqual=n}));t(h);h.deepEqual;var f=e((function(t,e){Object.defineProperty(e,"__esModule",{value:!0}),e.union=function(t,e){if(!t)return e||[];if(!e)return t;for(const n of e)-1===t.indexOf(n)&&t.push(n);return t},e.without=function(t,e){if(!t)return[];const n=t.indexOf(e);return-1!==n&&t.splice(n,1),t}}));t(f);f.union,f.without;var p=e((function(t,e){Object.defineProperty(e,"__esModule",{value:!0});e.SimpleEventEmitter=class{constructor(){this.onListeners={},this.onceListeners={}}on(t,e){this.onListeners[t]=f.union(this.onListeners[t],[e])}once(t,e){this.onceListeners[t]=f.union(this.onceListeners[t],[e])}off(t,e){this.onListeners[t]=f.without(this.onListeners[t],e),this.onceListeners[t]=f.without(this.onceListeners[t],e)}emit(t,...e){if(this.onListeners[t])for(const n of this.onListeners[t])n.call(null,...e);if(this.onceListeners[t]&&this.onceListeners[t].length>0){for(const n of this.onceListeners[t])n.call(null,...e);this.onceListeners[t]=[]}}emitAndWaitForCompletion(t,...e){const n=[];if(this.onListeners[t])for(const s of this.onListeners[t])try{n.push(Promise.resolve(s.call(null,...e)))}catch(t){n.push(Promise.reject(t))}if(this.onceListeners[t]&&this.onceListeners[t].length>0){for(const s of this.onceListeners[t])try{n.push(Promise.resolve(s.call(null,...e)))}catch(t){n.push(Promise.reject(t))}this.onceListeners[t]=[]}return Promise.all(n).then(t=>{})}}}));t(p);p.SimpleEventEmitter;var d=e((function(t,e){Object.defineProperty(e,"__esModule",{value:!0});function n(t,e){return t<e?-1:t>e?1:0}e.SortedArray=class{constructor(t=n,e=[]){this.array=[],this.compareFunction=t||n;const s=e.length;for(let t=0;t<s;t++)this.insert(e[t])}getData(){return this.array}insert(t){let e=this.searchInternal(t)+1;const n=this.array.length-1;for(;e<n&&0===this.compareFunction(t,this.array[e]);)e++;let s=this.array.length;for(this.array.push(t);s>e;)this.array[s]=this.array[--s];this.array[e]=t}search(t){const e=this.searchInternal(t);return 0!==this.compareFunction(this.array[e],t)?-1:e}remove(t){const e=this.search(t);e>=0&&this.array.splice(e,1)}searchInternal(t){let e,n,s=this.array.length-1,r=0;for(;s>=r;)if(e=Math.floor((s+r)/2),n=this.compareFunction(this.array[e],t),n<0)r=e+1;else{if(!(n>0))return e;s=e-1}return s}}}));t(d);d.SortedArray;var g=e((function(t,e){Object.defineProperty(e,"__esModule",{value:!0});e.INTERNAL_MOCKER_NAME="__internalMocker",e.printObject=function(t){if(null===t)return"null";if(void 0===t)return"undefined";if(t instanceof RegExp)return t.toString();const e=function(t){const e=t.__internalMocker;return null!=e?e:null}(t);return null!==e?e.mockName:JSON.stringify(t)}}));t(g);g.INTERNAL_MOCKER_NAME,g.printObject;var m=e((function(t,e){Object.defineProperty(e,"__esModule",{value:!0}),e.any=function(){const t={precedence:-1,matches:()=>!0,description:()=>"any()",equals:e=>e.description()===t.description()};return t},e.gt=function(t){const e={matches:e=>e>t,description:()=>`gt(${g.printObject(t)})`,equals:t=>t.description()===e.description()};return e},e.lt=function(t){const e={matches:e=>e<t,description:()=>`lt(${g.printObject(t)})`,equals:t=>t.description()===e.description()};return e},e.gte=function(t){const e={matches:e=>e>=t,description:()=>`gte(${g.printObject(t)})`,equals:t=>t.description()===e.description()};return e},e.lte=function(t){const e={matches:e=>e<=t,description:()=>`lte(${g.printObject(t)})`,equals:t=>t.description()===e.description()};return e},e.eq=function(t){const e={precedence:1,matches:e=>h.deepEqual(t,e),description:()=>g.printObject(t),equals:t=>t.description()===e.description()};return e},e.startsWith=function(t){const e={matches:e=>e.startsWith(t),description:()=>"startsWith "+t,equals:t=>t.description()===e.description()};return e},e.regexMatches=function(t){const e={matches:e=>t.test(e),description:()=>t.toString(),equals:t=>t.description()===e.description()};return e},e.matcher=function(t){const e={matches:e=>t(e),description:()=>t.toString(),equals:t=>t.description()===e.description()};return e}}));t(m);m.any,m.gt,m.lt,m.gte,m.lte,m.eq,m.startsWith,m.regexMatches,m.matcher;var x=e((function(t,e){Object.defineProperty(e,"__esModule",{value:!0}),e.deepEqual=h.deepEqual,e.SimpleEventEmitter=p.SimpleEventEmitter,e.SortedArray=d.SortedArray,e.any=m.any,e.eq=m.eq,e.gt=m.gt,e.gte=m.gte,e.lt=m.lt,e.lte=m.lte,e.matcher=m.matcher,e.regexMatches=m.regexMatches,e.startsWith=m.startsWith,e.INTERNAL_MOCKER_NAME=g.INTERNAL_MOCKER_NAME,e.printObject=g.printObject}));t(x);x.deepEqual,x.SimpleEventEmitter,x.SortedArray,x.any,x.eq,x.gt,x.gte,x.lt,x.lte,x.matcher,x.regexMatches,x.startsWith,x.INTERNAL_MOCKER_NAME,x.printObject;var y=e((function(t,e){Object.defineProperty(e,"__esModule",{value:!0});class n extends Error{constructor(t,e){super(e?t+"\n"+e:t)}}class s{static that(t){}static equal(t,e,s){if(!x.deepEqual(t,e))throw new n(`Expected ${x.printObject(e)} to deeply equal ${x.printObject(t)}`,s)}static notEqual(t,e,s){if(x.deepEqual(t,e))throw new n(`Expected ${x.printObject(e)} to not deeply equal ${x.printObject(t)}`,s)}static looseEqual(t,e,s){if(e!=t)throw new n(`Expected ${x.printObject(t)} == ${x.printObject(e)}`,s)}static notLooseEqual(t,e,s){if(e==t)throw new n(`Expected ${x.printObject(t)} != ${x.printObject(e)}`,s)}static strictEqual(t,e,s){if(!Object.is(e,t))throw new n(`Expected ${x.printObject(t)} to strictly equal ${x.printObject(e)}`,s)}static notStrictEqual(t,e,s){if(Object.is(e,t))throw new n(`Expected ${x.printObject(t)} to not strictly equal ${x.printObject(e)}`,s)}static is(t,e,n){s.strictEqual(t,e,n)}static has(t,e,n,r){s.exists(t,"target"),s.exists(e,"keyPath"),s.exists(t,"target");const i=e.split(".");let o=t;for(const t of i){const e=o[t];e||s.fail(`Missing key "${t}" in object ${x.printObject(o)}\nAvailable keys: ${x.printObject(Object.keys(n))}`),o=e}s.strictEqual(o,n,r)}static regexMatches(t,e,s){if(!e.test(t))throw new n(`Expected ${x.printObject(t)} to match the regex ${x.printObject(e)}`,s)}static resolvesTo(t,e,r){return t.then(t=>{s.equal(t,e)},t=>{throw new n(`Promise should not have successfully resolved.\nException: ${t}\n`,r)})}static rejects(t,e,r){const i=e instanceof Error?e.message:e;return t.then(()=>{throw new n("Promise should not have successfully resolved",r)},t=>{i&&s.equal(i,t.message)})}static fail(t){throw new n("Test failed",t)}static isTrue(t,e){s.equal(!0,t,e)}static isFalse(t,e){s.equal(!1,t,e)}static isTruthy(t,e){if(!t)throw new n(`Expected ${t} to be truthy`,e)}static isFalsy(t,e){if(t)throw new n(`Expected ${t} to be falsy`,e)}static exists(t,e){return this.notEqual(t,null,`Expected ${x.printObject(t)} to not be null. ${e}`),this.notEqual(t,void 0,`Expected ${x.printObject(t)} to not be undefined. ${e}`),!0}static contains(t,e,n){if(this.exists(t),"string"==typeof t)s.isTrue(-1!==t.indexOf(e),`String: ${e} was not found in ${t}`);else if(Array.isArray(t))s.isTrue(-1!==t.indexOf(e),`${x.printObject(e)} was not found in target array ${x.printObject(t)}. ${null!=n?n:""}`);else for(const[n,r]of Object.entries(e))s.equal(t[n],r)}static containsAll(t,e,n){this.exists(t),this.exists(e);for(const r of e)s.contains(t,r,n)}}e.Assert=s}));t(y);y.Assert;var E=e((function(t,e){Object.defineProperty(e,"__esModule",{value:!0});class n{constructor(t){this.target=t}toBe(t){y.Assert.equal(this.target,t)}toHaveProperty(t,e){y.Assert.has(this.target,t,e)}toBeTruthy(){y.Assert.isTruthy(this.target)}toBeFalsy(){y.Assert.isFalsy(this.target)}}e.Expect=n,e.expect=function(t){return new n(t)}}));t(E);E.Expect,E.expect;var b=e((function(t,e){Object.defineProperty(e,"__esModule",{value:!0}),e.assert=y.Assert,e.Expect=E.Expect,e.expect=E.expect}));t(b);b.assert,b.Expect,b.expect;var O=e((function(t,e){Object.defineProperty(e,"__esModule",{value:!0});class n{constructor(){this.all=[]}get first(){return 0===this.all.length?null:this.all[0]}get last(){return 0===this.all.length?null:this.all[this.all.length-1]}matches(t){return this.all.push(t),!0}description(){return 0===this.all.length?"Argument captor. No arguments captured":"Argument captor. Currently captured args: "+this.all}equals(t){return t instanceof n&&t.all===this.all}}e.newCapture=function(){return new n}}));t(O);O.newCapture;var M=e((function(t,e){function n(t){const e=t[x.INTERNAL_MOCKER_NAME];return null!=e?e:null}Object.defineProperty(e,"__esModule",{value:!0}),e.INTERNAL_MOCKER_NAME=x.INTERNAL_MOCKER_NAME,e.GetInternalMockerSafe=n,e.GetInternalMocker=function(t){const e=n(t);if(null===e)throw new Error("Passed an object that was not a mock. Object: "+t.toString());return e},e.CreateInternalMocker=function(t,e,n,s){const r={expectations:[],recordedInvocations:[],realFunction:e,options:s,inProgressInOrder:[],isInExpectation:!1,mockName:null!=n?n:"mock"};return t[x.INTERNAL_MOCKER_NAME]=r,r}}));t(M);M.INTERNAL_MOCKER_NAME,M.GetInternalMockerSafe,M.GetInternalMocker,M.CreateInternalMocker;var v=e((function(t,e){Object.defineProperty(e,"__esModule",{value:!0});e.StacktraceUtils=class{static getCurrentMockLocation(t){const e=(new Error).stack;if(void 0===e)return null;const n=e.split("\n");if(n.length<t+2)return null;const s=n[t+1],r=/.*?\((.*?)\)/.exec(s);return null===r?null:r[1]}}}));t(v);v.StacktraceUtils;var w=e((function(t,e){function n(t,e){const n=new x.SortedArray((t,e)=>{if(void 0===t&&void 0===e)return 0;if(void 0===t)return 1;if(void 0===e)return-1;if(null!==t.inOrderOverride&&null==e.inOrderOverride)return-1;if(null===t.inOrderOverride&&null!==e.inOrderOverride)return 1;if(null===t.expectedArgs&&null===e.expectedArgs)return 0;if(null===t.expectedArgs)return 1;if(null===e.expectedArgs)return-1;const n=e.expectedArgs.length-t.expectedArgs.length;if(0!==n)return n;const r=s(t.expectedArgs);return s(e.expectedArgs)-r});for(const e of t)n.insert(e);for(const t of n.getData()){if(t.callCount>=t.expectedRange.end)continue;if(r(t.expectedArgs,e))return t}return null}function s(t){let e=0;for(const n of t)e+=void 0!==n.precedence?n.precedence:0;return e}function r(t,e){if(null===t)return!0;if(e.length<t.length)return!1;let n=!0;0===t.length&&(n=0===e.length);for(let s=0;s<t.length;s++){const r=t[s],i=e[s];n=n&&r.matches(i)}return n}Object.defineProperty(e,"__esModule",{value:!0}),e.findBestArgumentMatcher=n,e.verifyArgumentMatcher=r;const i={includeLocation:!0};function o(t,e=i){let n="\t"+(t.internalMocker.mockName||"mock");if(null===t.expectedArgs)n+="() with any arguments";else{const e=[];for(const n of t.expectedArgs)n.description?e.push(n.description()):e.push(n.toString());n+=`(${e.join(", ")})`}return n+=`. Expected ${t.expectedRange.describeRange()}, so far ${t.callCount}.`,e.includeLocation&&(n+="\n\tExpectation set at "+t.location),n+"\n"}e.createMockedFunction=function(){const t=(...e)=>{const s=M.GetInternalMocker(t),r=v.StacktraceUtils.getCurrentMockLocation(2);s.recordedInvocations.push({params:e,location:r});const i=n(s.expectations,e);if(null!==i){if(i.inOrderOverride){const t=i.inOrderOverride,e=t.expectations[t.currentIndex];if(e!==i){const t=o(e);throw new Error(`Out of order method call.\nExpected:\n${t}\nActual:\n`+o(i,{includeLocation:!1})+"\tCalled at "+r)}if(0===t.currentIndex&&s.inProgressInOrder.push(t),t.currentIndex++,t.currentIndex>t.expectations.length){const e=s.inProgressInOrder.indexOf(t);if(-1===e)throw new Error("Could not find in progress index");s.inProgressInOrder.splice(e,1)}}else if(s.inProgressInOrder.length>0)throw new Error("Out of order method call.");if(i.callCount++,!i.answer)return;return i.answer(...e)}if(s.options.strictMode===k.StrictnessMode.Strict){let n="";for(const t of s.expectations)n+=o(t)+"\n";n=n?`\nExpectations:\n${n} `:"";const r=s.expectations.length>0?"matched":"was set",i=[];for(const t of e)i.push(x.printObject(t));const c=i.join(", ");throw new Error(`${t.name}(${c}) was called but no expectation ${r}.${n}`)}return null};return t}}));t(w);w.findBestArgumentMatcher,w.verifyArgumentMatcher,w.createMockedFunction;var A=e((function(t,e){Object.defineProperty(e,"__esModule",{value:!0});e.Range=class{constructor(t,e=t){if(t<0)throw new Error("Start value must be >= 0. Received "+t);if(e<1)throw Error("End value must be >= 1. Received "+e);if(t>e)throw new Error(`Start must be <= end. Start: ${t} End: ${e}`);this.start=t,this.end=e}isFixedRange(){return this.start===this.end}isInRange(t){return t>=this.start&&t<=this.end}hasNoUpperBound(){return this.end===Number.MAX_SAFE_INTEGER}describeRange(){return this.isFixedRange()?this.start+" invocations":this.hasNoUpperBound()?`at least ${this.start} invocations`:`between ${this.start} and ${this.end} invocations`}}}));t(A);A.Range;var R=e((function(t,e){function n(t){return function(){return t}}function s(t){const e=[];for(const n of t){const t=null===M.GetInternalMockerSafe(n)&&"function"==typeof n.matches?n:x.eq(n);e.push(t)}return e}Object.defineProperty(e,"__esModule",{value:!0}),e.normalizeMatcherArgs=s;class r extends b.Expect{constructor(t){super(t),this.atMostCount=-1,this.atLeastCount=-1,this.timesCount=-1,this.internalMocker=M.GetInternalMocker(t),this.currentArgumentExpectations=null,this.internalMocker.isInExpectation=!0;const e={internalMocker:this.internalMocker,expectedRange:new A.Range(1),location:v.StacktraceUtils.getCurrentMockLocation(3),answer:null,expectedArgs:this.currentArgumentExpectations,callCount:0,inOrderOverride:null};this.internalMocker.expectations.push(e),this.expectation=e}getExpectation(){return this.expectation}withArgs(...t){return this.currentArgumentExpectations=s(t),this.expectation.expectedArgs=this.currentArgumentExpectations,this}andReturn(t){return this.expectation.answer=n(t),this}andStubReturn(t){this.expectation.answer=n(t),this.atLeast(0)}andThrow(t){return this.expectation.answer=function(t){return function(){throw t}}(t),this}andCallRealMethod(){const t=this.internalMocker.realFunction;if(!t)throw new Error("No function was available. Ensure a real object was passed to the spy");return this.expectation.answer=function(t){return function(...e){return t(e)}}(t),this}andAnswer(t){return this.expectation.answer=t,this}andResolve(t){return this.expectation.answer=function(t){return function(){return Promise.resolve(t)}}(t),this}andReject(t){return this.expectation.answer=function(t){return function(){return Promise.reject(t)}}(t),this}times(t){if(-1!==this.timesCount||-1!==this.atLeastCount||-1!==this.atMostCount)throw new Error("Previously set expectation count, value must only be set once");return this.timesCount=t,this.setExpectedRange(new A.Range(t)),this}once(){return this.times(1)}twice(){return this.times(2)}atMost(t){if(-1!==this.timesCount||-1!==this.atMostCount&&this.atMostCount!==Number.MAX_SAFE_INTEGER)throw new Error("Previously set expectation count, value must only be set once");return this.atMostCount=t,this.atLeastCount=-1!==this.atLeastCount?this.atLeastCount:0,this.setExpectedRange(new A.Range(this.atLeastCount,this.atMostCount)),this}atLeast(t){if(-1!==this.timesCount||-1!==this.atLeastCount&&0!==this.atLeastCount)throw new Error("Previously set expectation count, value must only be set once");return this.atLeastCount=t,this.atMostCount=-1!==this.atMostCount?this.atMostCount:Number.MAX_SAFE_INTEGER,this.setExpectedRange(new A.Range(this.atLeastCount,this.atMostCount)),this}setExpectedRange(t){const e=this.internalMocker.expectations;if(e.length>1&&t.isFixedRange()){const t=e[e.length-1],n=e[e.length-2];if(!n.expectedRange.isFixedRange()&&this.doArgumentsMatch(n,t))throw new Error("Previous expectation had a non fixed range.")}this.expectation.expectedRange=t}doArgumentsMatch(t,e){if(null===e.expectedArgs||null===t.expectedArgs)return null===t.expectedArgs&&null===e.expectedArgs;if(e.expectedArgs.length!==t.expectedArgs.length)return!1;for(let n=0;n<e.expectedArgs.length;n++){const s=t.expectedArgs[n];if(!e.expectedArgs[n].equals(s))return!1}return!0}}e.OnGoingStubs=r}));t(R);R.normalizeMatcherArgs,R.OnGoingStubs;var k=e((function(t,e){var n;Object.defineProperty(e,"__esModule",{value:!0}),function(t){t[t.Strict=0]="Strict",t[t.Loose=1]="Loose"}(n||(n={})),e.StrictnessMode=n;class s{constructor(t,e,n,s){this.cachedStubs={},this.cachedFunctionStub=null,this.clazz=t,this.realObject=e,this.mockName=n,this.options=s}apply(t,e,n){if(t===this.realObject)return this.mockSingleFunctionIfNecessary(this.realObject),this.cachedFunctionStub(...n);t(n)}get(t,e,n){if(e===M.INTERNAL_MOCKER_NAME)return this.mockSingleFunctionIfNecessary(t[e]),this.cachedFunctionStub[M.INTERNAL_MOCKER_NAME];if(this.clazz){const t=this.clazz[e];if(null==t){const t=Object.getOwnPropertyNames(this.clazz).join(", ");throw new Error(`Method "${e.toString()}" was called on class "${this.clazz.constructor.name}". Ensure method exists on prototype. Valid methods: [${t}]`)}}if(!this.cachedStubs[e]){const n=w.createMockedFunction(),s=null!==this.mockName?`${this.mockName}.${e.toString()}`:e.toString();Object.defineProperty(n,"name",{value:s});const r=M.CreateInternalMocker(n,t[e],s,this.options);r.isInExpectation&&(r.isInExpectation=!1),this.cachedStubs[e]=n}return this.cachedStubs[e]}enumerate(t){return this.ownKeys(t)}ownKeys(t){return Object.keys(this.cachedStubs)}getOwnPropertyDescriptor(t,e){return Object.getOwnPropertyDescriptor(this.cachedStubs,e)}isExtensible(t){return!1}mockSingleFunctionIfNecessary(t){if(!this.cachedFunctionStub){const e=w.createMockedFunction();null!==this.mockName&&Object.defineProperty(e,"name",{value:this.mockName});const n=M.CreateInternalMocker(e,t,this.mockName,this.options);n.isInExpectation&&(n.isInExpectation=!1),this.cachedFunctionStub=e}}}let r={strictMode:n.Strict,inOrder:!1};e.setDefaultOptions=function(t){r=Object.assign(r,t)},e.mock=function(t,e,n=r){const i=()=>{};return"string"==typeof t&&(e=t,t=void 0),e||(e=null),new Proxy(i,new s(t?t.prototype:null,i,e,n))},e.spy=function(t,e=r){return new Proxy(t,new s(Object.getPrototypeOf(t),t,null,e))},e.expect=function(t){return new R.OnGoingStubs(t)},e.inOrder=function(...t){const e={expectations:[],currentIndex:0},n=t;for(const t of n){const n=t.getExpectation();e.expectations.push(n),n.inOrderOverride=e}}}));t(k);k.StrictnessMode,k.setDefaultOptions,k.mock,k.spy,k.expect,k.inOrder;var j=e((function(t,e){function n(t){const e=M.GetInternalMocker(t),r=Object.keys(t);for(const e of r){if(e===M.INTERNAL_MOCKER_NAME)continue;const s=t[e];if(s){M.GetInternalMocker(s)&&n(s)}}for(const t of e.expectations)if(!t.expectedRange.isInRange(t.callCount))throw new Error(s(e.recordedInvocations,t))}function s(t,e){const n=function(t,e){const n=[];for(const s of e)null===t&&null!==s.location&&n.push(s.location);return n}(e.expectedArgs,t),s=(r=e.expectedRange,i=e.callCount,`Expected ${r.describeRange()}, got ${i}.`);var r,i;const o=n.length>0?"Called at:\n"+n.join("\n"):"";return`${s}\nExpected at: ${e.location}\n${o}\n `}Object.defineProperty(e,"__esModule",{value:!0}),e.verify=function(...t){for(const e of t)n(e)}}));t(j);j.verify;var C=e((function(t,e){Object.defineProperty(e,"__esModule",{value:!0}),e.any=x.any,e.eq=x.eq,e.gt=x.gt,e.gte=x.gte,e.lt=x.lt,e.lte=x.lte,e.matcher=x.matcher,e.regexMatches=x.regexMatches,e.startsWith=x.startsWith,e.newCapture=O.newCapture,e.expect=k.expect,e.inOrder=k.inOrder,e.mock=k.mock,e.setDefaultOptions=k.setDefaultOptions,e.spy=k.spy,e.verify=j.verify}));t(C);C.any,C.eq,C.gt,C.gte,C.lt,C.lte,C.matcher,C.regexMatches,C.startsWith,C.newCapture,C.expect,C.inOrder,C.mock,C.setDefaultOptions,C.spy,C.verify;var P=e((function(t,e){Object.defineProperty(e,"__esModule",{value:!0}),e.TestRunner=l.TestRunner,e.assert=b.assert,e.any=C.any,e.eq=C.eq,e.expect=C.expect,e.gt=C.gt,e.gte=C.gte,e.inOrder=C.inOrder,e.lt=C.lt,e.lte=C.lte,e.matcher=C.matcher,e.mock=C.mock,e.newCapture=C.newCapture,e.regexMatches=C.regexMatches,e.setMockOptions=C.setDefaultOptions,e.spy=C.spy,e.startsWith=C.startsWith,e.verify=C.verify})),I=t(P),S=P.TestRunner,_=P.assert,T=P.any,L=P.eq,N=P.expect,q=P.gt,$=P.gte,F=P.inOrder,D=P.lt,Q=P.lte,W=P.matcher,G=P.mock,K=P.newCapture,z=P.regexMatches,B=P.setMockOptions,U=P.spy,V=P.startsWith,X=P.verify;exports.TestRunner=S,exports.any=T,exports.assert=_,exports.default=I,exports.eq=L,exports.expect=N,exports.gt=q,exports.gte=$,exports.inOrder=F,exports.lt=D,exports.lte=Q,exports.matcher=W,exports.mock=G,exports.newCapture=K,exports.regexMatches=z,exports.setMockOptions=B,exports.spy=U,exports.startsWith=V,exports.verify=X;
//# sourceMappingURL=umbra.js.map
